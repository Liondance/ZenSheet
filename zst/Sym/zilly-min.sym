///
/// zilly.sym
///
/// ZenVM reactive integer calculator experiment
///

//

sys.reset();

// Hidden (language adapter - conversions)

:: B   := fn(int x) => bool -> x <> 0; 
:: I   := fn(bool b) => int -> if(b, 1, 0);

// Primitive functions

:: minus := fn(int x) => fun(int y) => int -> fn(int y) => int -> x - y;
:: lt := fn(int x) => fun(int y) => int -> fn(int y) => int -> I(x < y);

// Derived

:: and := fn(int x) => fun(int y) => int -> fn(int y) => int -> if(B(x), y, 0);

:: or := fn(int x) => fun(int y) => int -> fn(int y) => int -> if(B(x), 1, y);

:: not := fn(int x) => int -> if(B(x), 0, 1);

:: gt := fn(int x) => fun(int y) => int -> fn(int y) => int -> lt(y)(x);

// :: le := fn(int x) => fun(int y) => int -> fn(int y) => int -> not(gt(x)(y));

// :: ge := fn(int x) => fun(int y) => int -> fn(int y) => int -> not(lt(x)(y));

:: ne := fn(int x) => fun(int y) => int -> fn(int y) => int -> or(lt(x)(y))(lt(y)(x));

:: eq := fn(int x) => fun(int y) => int -> fn(int y) => int -> not(ne(x)(y));

:: le := fn(int x) => fun(int y) => int -> fn(int y) => int -> or(lt(x)(y))(eq(x)(y));

:: ge := fn(int x) => fun(int y) => int -> fn(int y) => int -> or(gt(x)(y))(eq(x)(y));

:: chs := fn(int x) => int -> minus(0)(x);

:: plus := fn(int x) => fun(int y) => int -> fn(int y) => int -> minus(x)(chs(y));

// Future enhancement (performance): switch arguments when necessary so that x is smaller than y
:: _mult := fn(int x) => fun(int y) => int -> fn(int y) => int -> if(B(eq(x)(0)), 0, plus(_mult(minus(x)(1))(y))(y));
:: mult := fn(int x) => fun(int y) => int -> fn(int y) => int -> if(B(lt(0)(x)), _mult(x)(y), chs(_mult(chs(x))(y)));

verify minus(9)(7) =  2
verify minus(7)(9) = -2

verify lt(6)(7) = 1
verify lt(7)(6) = 0

verify chs(-1) =  1
verify chs( 0) =  0
verify chs( 1) = -1

verify plus(9)(7) = 16
verify plus(7)(9) = 16

verify and(0)(0) = 0
verify and(0)(1) = 0
verify and(1)(0) = 0
verify and(1)(1) = 1

verify or(0)(0) = 0
verify or(0)(1) = 1
verify or(1)(0) = 1
verify or(1)(1) = 1

verify not(0) = 1
verify not(1) = 0

verify lt(7)(9) = 1
verify lt(9)(7) = 0
verify lt(9)(9) = 0

verify le(7)(9) = 1
verify le(9)(7) = 0
verify le(9)(9) = 1

verify ne(7)(9) = 1
verify ne(9)(7) = 1
verify ne(9)(9) = 0

verify eq(7)(9) = 0
verify eq(9)(7) = 0
verify eq(9)(9) = 1

verify ge(7)(9) = 0
verify ge(9)(7) = 1
verify ge(9)(9) = 1

verify gt(7)(9) = 0
verify gt(9)(7) = 1
verify gt(9)(9) = 0

verify mult(-6)(-7) =  42
verify mult(-6)( 7) = -42
verify mult( 6)(-7) = -42
verify mult( 6)( 7) =  42

//

:: mod := fn(x) -> fn(y) -> if(B(lt(x)(y)), x, mod(minus(x)(y))(y));
:: div := fn(x) -> fn(y) -> if(B(lt(x)(y)), 0, plus(1)(div(minus(x)(y))(y)));
:: gcd := fn(x) -> fn(y) -> if(B(lt(x)(y)), gcd(y)(x), if(B(eq(mod(x)(y))(0)), y, gcd(y)(minus(x)(y))));

:: x := 3768;
:: y := 1472;
:: z :- gcd(x)(y);

verify mod(x)(y) = x % y
verify div(x)(y) = quotient(x, y)
verify plus(mult(y)(div(x)(y)))(mod(x)(y)) = x
verify eq(plus(mult(div(x)(y))(y))(mod(x)(y)))(x) = 1
verify z = 8

x :=   10;
y := 1000;

verify eq(plus(mult(div(x)(y))(y))(mod(x)(y)))(x) = 1
verify z = 10

x := 1000;
y := 10;

verify eq(plus(mult(div(x)(y))(y))(mod(x)(y)))(x) = 1
verify z = 10

x := 24;
y := 32;

verify eq(plus(mult(div(x)(y))(y))(mod(x)(y)))(x) = 1
verify z = 8

x := mult(1393)(427);
y := plus(mult(7)(x))(997);

verify eq(plus(mult(div(x)(y))(y))(mod(x)(y)))(x) = 1
verify z = 1

y := mult(1393)(427);
x := plus(mult(7)(y))(997);

verify eq(plus(mult(div(x)(y))(y))(mod(x)(y)))(x) = 1
verify z = 1

x := mult(2401)(497);
y := plus(mult(7)(x))(997);

verify eq(plus(mult(div(x)(y))(y))(mod(x)(y)))(x) = 1
verify z = 1

y := mult(2401)(497);
x := plus(mult(7)(y))(997);

verify eq(plus(mult(div(x)(y))(y))(mod(x)(y)))(x) = 1
verify z = 1

//

verify true
